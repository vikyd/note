# Why Add Versions To Go?

原文：https://research.swtch.com/vgo-why-versions

作者：[Russ Cox](https://swtch.com/~rsc/)

翻译时间：2019-11-16

# 为什么要为 Go 添加版本管理功能？

（[Go 与版本管理](https://research.swtch.com/vgo)，第 10 部分）

发表时间：2018-06-07 周四 [PDF](https://research.swtch.com/vgo-why-versions.pdf)

# 目录

<!-- START doctoc -->
<!-- END doctoc -->

# 正文

人们有时问我为什么要为 Go 语言添加包版本管理功能？现在的 Go 不够用了么？通常，这些人在其他语言中也没有好的版本经验，他们将版本与破坏性修改联系在一起。本文将介绍为什么我们需要在 Go 语言中添加包版本管理功能。之后的文章将介绍为什么我们不鼓励破坏性修改。

因对版本管理的忽略，`go get` 命令有 2 种失败场景：使用太旧的代码，以及使用太新的代码。假如我们想使用 D 包，此时还没有安装任何包，可以执行 `go get D`。`go get` 命令会下载最新的 D 代码（即 `git clone` 下载到的内容），并构建成功。为了描述得更清楚，我们将此份代码称为 D 的 1.0 版本，并记住我们的代码对 D 依赖细节（或如下图）。但注意，现在只是我们脑子里理解这其中的依赖细节，但 `go get` 并不理解。

```sh
$ go get D
```

![go get D](https://research.swtch.com/vgo-why-1@2x.png)

假设时间已到了一个月后，我们想使用 C 包，而 C 是依赖于 D 的。我们执行 `go get C`。`go get` 命令下载了 C 的最新代码，且 C 1.8 依赖了 D。而由于 `go get` 之前已下载过一份 D 的代码，所以它会直接使用这个已下载的 D 代码，而非再次下载新的 D。问题来了，此时 C 构建失败了：C 使用了 D 1.4 的新功能，但 `go get` 却依然使用 D 1.0。也即是说，此时 D 的代码太旧了。

```sh
$ go get C
```

![go get C](https://research.swtch.com/vgo-why-2@2x.png)

下一步，我们执行 `go get -u`，此时会下载所有包的最新代码，即使有些代码曾经下载过。

```sh
$ go get -u C
```

![go get -u C](https://research.swtch.com/vgo-why-3@2x.png)

问题又来了，1 小时前，D 刚发布了 1.6 版本，此版本引入了 1 个 bug，并导致其的 C 构建失败了。也即是说现在 D 的代码太新了。由上述例子可知，`go get` 应使用 `D ≥ 1.4` 但不是 `D 1.6`，可以是 `D 1.4` 或 `D 1.5`。目前的 `go get` 很难区分包版本含义。

现在回到文章最开始的问题：为什么要为 Go 添加版本管理功能？

这是因为在版本系统上达成统一规则（一种版本标识符的语法，以及如何排序和理解这些标识符），可为我们提供一种更精确的沟通方式，更精确地与我们的工具、其他人沟通，沟通关于如何描述我们所指的包。正如我们所知的那样，版本控制对于能正确构建很重要，而且也能延伸出一些有趣的相关工具。

例如，最易想到的是可以列出某个版本的包所使用的依赖包的版本列表，并可检查是否有版本可更新。概况地说，可以做出这么一个工具能够：检查一些列构建，可以是一个公司的所有构建目标，并组装出相同的构建列表。这样的版本列表可接受兼容性检查，记录到 bug 数据库等等。将版本列表嵌入到构建的二进制文件中，还可允许一个程序自行进行这些检查。当然，这些想法并不是我首创的，这些想法已经在其他系统中有应用了。关键在于，建立统一的版本系统可延伸出这些有用工具，这些工具甚至可以在语言的工具链之外进行构建。

我们还可将版本查询工具（可以告诉你代码的工具）变为开发工具，即可以自动帮你更新代码。例如，下一个最易想到的是自动更新包依赖列表的工具，只要包及其依赖的测试都能通过，就能自动更新。只要能描述版本，也就能延伸出自动整理代码的工具。例如，有这么一些版本：当 D ≥ 1.4 时，可将客户端代码的所有 `x.Foo(1).Bar(2)` 替换为 `x.FooBar()`，如可执行这样的工具：`go fix`。

我们将版本管理功能添加到 Go 的核心工具链中（或更概况地说，将它们添加到 Go 开发者与我们工具的统一描述方式中）的目标是建立一个基础，解决诸如构建程序之类的核心问题，或者允许延伸出更多有用的外部工具。当然，还有一些我们尚未想到的工具。

如果我们要为其他工具建立基础，这个基础应尽可能的功能齐全、强大、健壮，才能更少阻碍工具的建立。我们不仅是在写一个工具，更是在定义所有这些工具的统一协作方式。从广义上看，这个基础是这些工具依赖的 API。就像任何 API 一样，我们希望尽可能将其设计得足够强大，以满足各种需求，同时又要很简单、可靠、一致、兼容、可预测。未来的文章将介绍 vgo 的设计决策是如何到达这些目标的。
